using AutoMapper;
using Microsoft.EntityFrameworkCore;
using TFT_API.Data;
using TFT_API.Models.AutoGeneratedGuide;
using TFT_API.Models.FetchResponse;
using TFT_API.Models.Match;
using TFT_API.Models.Stats.TraitStats;
using TFT_API.Models.Stats.UnitStats;
using TFT_API.Models.Trait;
using TFT_API.Models.Unit;
using TFT_API.Models.UserGuides;

namespace TFT_API.Services
{
    public class TeamBuilderService
    {
        private readonly TFTContext _context;
        private List<Match> _matchList;
        private List<PersistedUnit> _units;
        private List<TraitStat> _traitStats;
        private List<UnitStat> _unitStats;
        private List<PersistedTrait> _traits;
        private Dictionary<string, Dictionary<string, int>> _unitCooccurrence;
        private Dictionary<string, Dictionary<string, int>> _unitItemRates;
        private Dictionary<string, Dictionary<string, int>> _augmentStats;
        private Dictionary<string, Dictionary<string, int>> _emblems;
        private Dictionary<string, int> _unitThreeItemCounts;
        private Dictionary<string, int> _currentTraits;
        private int _matchCount;

        public TeamBuilderService(TFTContext context)
        {
            _context = context;
            _matchList = new List<Match>();
            _units = new List<PersistedUnit>();
            _traitStats = new List<TraitStat>();
            _unitStats = new List<UnitStat>();
            _traits = new List<PersistedTrait>();
            _unitCooccurrence = new Dictionary<string, Dictionary<string, int>>();
            _unitItemRates = new Dictionary<string, Dictionary<string, int>>();
            _augmentStats = new Dictionary<string, Dictionary<string, int>>();
            _emblems = new Dictionary<string, Dictionary<string, int>>();
            _unitThreeItemCounts = new Dictionary<string, int>();
            _currentTraits = new Dictionary<string, int>();
        }

        public async Task BuildTeams()
        {
            _units = _context.Units.Include(u => u.Traits).ToList();
            _traitStats = _context.TraitStats.AsNoTracking().ToList();
            _unitStats = _context.UnitStats.AsNoTracking().ToList();
            _traits = _context.Traits.ToList();
            var guides = new List<UserGuide>();
            _matchList = await _context.Matches.AsNoTracking().Include(m => m.Units).ToListAsync();
            await Task.WhenAll(_units.Select(unit =>
            {
                if (unit.Name == "Kayle") return Task.CompletedTask;
                var unitMatches = _matchList
                    .Where(m => m.Units.Any(u => u.CharacterId == unit.InGameKey && (u.ItemNames.Count == 3 || u.Tier == 3)))
                    .ToList();

                CalculateStatsForMatches(unitMatches);
                _matchCount = unitMatches.Count;

                var guide = BuildTeam(unit.InGameKey);
                guides.Add(guide);

                return Task.CompletedTask;
            }));

            await using var transaction = await _context.Database.BeginTransactionAsync();
            try
            {
                var hexesToRemove = _context.Hexes
                               .Where(h => h.AutoGeneratedGuideId != null)
                               .Select(h => h.Id)
                               .ToList();
                var hexItemsToRemove = _context.HexItems
                                               .Where(hi => hexesToRemove.Contains(hi.HexId))
                                               .ToList();
                _context.HexItems.RemoveRange(hexItemsToRemove);
                var hexesToRemoveEntities = _context.Hexes
                                                    .Where(h => h.AutoGeneratedGuideId != null)
                                                    .ToList();
                _context.Hexes.RemoveRange(hexesToRemoveEntities);
                var guideTraitsToRemove = _context.GuideTraits
                                                  .Where(gt => gt.AutoGeneratedGuideId != null)
                                                  .ToList();
                _context.GuideTraits.RemoveRange(guideTraitsToRemove);
                var guideAugmentsToRemove = _context.GuideAugments
                                                    .Where(ga => ga.AutoGeneratedGuideId != null)
                                                    .ToList();
                _context.GuideAugments.RemoveRange(guideAugmentsToRemove);
                _context.UserGuides.RemoveRange(_context.UserGuides.Where(ug => ug.isAutoGenerated == true));
                await _context.UserGuides.AddRangeAsync(guides);
                await _context.SaveChangesAsync();
                await transaction.CommitAsync();
            }
            catch (Exception ex)
            {
                await transaction.RollbackAsync();
            }
        }

        private void CalculateStatsForMatches(List<Match> matches)
        {
            foreach (var match in matches)
            {
                var unitsInMatch = match.Units.GroupBy(u => u.CharacterId).Select(g => g.First()).ToList();
                foreach (var unit in unitsInMatch)
                {
                    var unitCharacterId = unit.CharacterId;
                    if (!_unitCooccurrence.ContainsKey(unitCharacterId))
                    {
                        _unitCooccurrence[unitCharacterId] = new Dictionary<string, int>();
                    }
                    foreach (var coUnit in unitsInMatch)
                    {
                        var coUnitCharacterId = coUnit.CharacterId;
                        if (unitCharacterId == coUnitCharacterId) continue;
                        if (!_unitCooccurrence[unitCharacterId].ContainsKey(coUnitCharacterId))
                        {
                            _unitCooccurrence[unitCharacterId][coUnitCharacterId] = 0;
                        }
                        _unitCooccurrence[unitCharacterId][coUnitCharacterId]++;
                    }
                    if (!_unitItemRates.ContainsKey(unitCharacterId))
                    {
                        _unitItemRates[unitCharacterId] = new Dictionary<string, int>();
                    }
                    foreach (var item in unit.ItemNames)
                    {
                        if (item.Contains("Emblem"))
                        {
                            if (!_emblems.ContainsKey(unitCharacterId))
                            {
                                _emblems[unitCharacterId] = new Dictionary<string, int>();
                            }
                            if (!_emblems[unitCharacterId].ContainsKey(item))
                            {
                                _emblems[unitCharacterId][item] = 0;
                            }
                            _emblems[unitCharacterId][item]++;
                        }

                        if (!_unitItemRates[unitCharacterId].ContainsKey(item))
                        {
                            _unitItemRates[unitCharacterId][item] = 0;
                        }
                        _unitItemRates[unitCharacterId][item]++;
                    }
                    foreach (var augment in match.Augments)
                    {
                        if (!_augmentStats.ContainsKey(unit.CharacterId))
                        {
                            _augmentStats[unit.CharacterId] = new Dictionary<string, int>();
                        }
                        if (!_augmentStats[unit.CharacterId].ContainsKey(augment))
                        {
                            _augmentStats[unit.CharacterId][augment] = 0;
                        }
                        _augmentStats[unit.CharacterId][augment]++;
                    }
                    if (unit.ItemNames.Count == 3)
                    {
                        if (!_unitThreeItemCounts.ContainsKey(unitCharacterId))
                        {
                            _unitThreeItemCounts[unitCharacterId] = 0;
                        }
                        _unitThreeItemCounts[unitCharacterId]++;
                    }
                }
            }
        }

        private UserGuide BuildTeam(string initialUnit)
        {
            var team = new List<string> { initialUnit };
            InitializeTraits(initialUnit);

            while (team.Count < 9)
            {
                var bestUnit = FindBestUnit(team, initialUnit);
                if (string.IsNullOrEmpty(bestUnit)) break;

                team.Add(bestUnit);
                UpdateTraits(bestUnit);
            }

            AddStoryweaverUnitIfNeeded(team);

            var guide = CreateGuide(team, initialUnit);
            UpdateTraitsInGuide(guide);
            UpdateAugmentsInGuide(guide, team);

            return guide;
        }

        private void InitializeTraits(string initialUnit)
        {
            var initialUnitTraits = _units.First(u => u.InGameKey == initialUnit).Traits;
            foreach (var trait in initialUnitTraits)
            {
                if (!_currentTraits.ContainsKey(trait.Trait.Name))
                {
                    _currentTraits[trait.Trait.Name] = 0;
                }
                _currentTraits[trait.Trait.Name]++;
            }
        }

        private string FindBestUnit(List<string> team, string initialUnit)
        {
            var bestUnit = string.Empty;
            var bestScore = double.MinValue;

            foreach (var candidateUnit in _units)
            {
                var candidate = candidateUnit.InGameKey;
                if (team.Contains(candidate) || candidate == "TFT11_Kayle") continue;

                var score = CalculateScore(team, candidate, initialUnit, candidateUnit);

                if (score > bestScore)
                {
                    bestScore = score;
                    bestUnit = candidate;
                }
            }

            return bestUnit;
        }

        private double CalculateScore(List<string> team, string candidate, string initialUnit, PersistedUnit candidateUnit)
        {
            var score = 0.0;

            foreach (var member in team)
            {
                if (!_unitCooccurrence.ContainsKey(member)) continue;
                if (_unitCooccurrence[member].TryGetValue(candidate, out var coocurrence))
                {
                    if (member == initialUnit)
                    {
                        coocurrence *= 2;
                    }
                    score += coocurrence;
                }
            }

            foreach (var trait in candidateUnit.Traits)
            {
                var traitStats = _traitStats.Where(t => t.Name == trait.Trait.Name);
                foreach (var traitStat in traitStats)
                {
                    if (_currentTraits.ContainsKey(trait.Trait.Name) && _currentTraits[trait.Trait.Name] + 1 == traitStat.NumUnits)
                    {
                        score *= (1 + traitStat.Stat.Top4 / traitStat.Stat.Games);
                    }
                }
            }

            var candidateUnitStat = _unitStats.FirstOrDefault(us => us.Name == candidateUnit.Name);
            if (candidateUnitStat != null)
            {
                score *= (1 + (candidateUnitStat.Stat.Top4 / candidateUnitStat.Stat.Games));
            }

            return score;
        }

        private void UpdateTraits(string unit)
        {
            foreach (var trait in _units.First(u => u.InGameKey == unit).Traits)
            {
                if (!_currentTraits.ContainsKey(trait.Trait.Name))
                {
                    _currentTraits[trait.Trait.Name] = 0;
                }
                _currentTraits[trait.Trait.Name]++;
            }
        }

        private void AddStoryweaverUnitIfNeeded(List<string> team)
        {
            var storyweaverCount = _currentTraits.ContainsKey("Storyweaver") ? _currentTraits["Storyweaver"] : 0;
            if (storyweaverCount > 2)
            {
                team.Add("TFT11_Kayle");
            }
        }

        private UserGuide CreateGuide(List<string> team, string initialUnit)
        {
            var guideName = _context.Units.FirstOrDefault(u => u.InGameKey == team[0])?.Name ?? "";
            var patch = "14.11.1";

            var guide = new UserGuide
            {
                InitialUnit = _units.First(u => u.InGameKey == initialUnit),
                Name = guideName,
                Patch = patch,
                Hexes = team.Select((unit, index) => new Hex
                {
                    Unit = _units.First(u => u.InGameKey == unit),
                    Coordinates = index,
                    IsStarred = false,
                    CurrentItems = new List<HexItem>()
                }).ToList(),
                isAutoGenerated = true,
            };

            var itemSlots = 10;
            var sortedUnits = team.OrderByDescending(unit => _unitThreeItemCounts.ContainsKey(unit) ? _unitThreeItemCounts[unit] : 0).ToList();
            sortedUnits.Remove(initialUnit);
            sortedUnits.Insert(0, initialUnit);
            var mostUsedEmblem = GetMostUsedEmblem();
            var emblemUsagePercentage = CalculateEmblemUsagePercentage();
            if (emblemUsagePercentage > 15 && mostUsedEmblem != null)
            {
                var unitWithHighestEmblemRate = GetUnitWithHighestEmblemRate(mostUsedEmblem);

                if (!string.IsNullOrEmpty(unitWithHighestEmblemRate))
                {
                    var hex = guide.Hexes.FirstOrDefault(h => h.Unit.InGameKey == unitWithHighestEmblemRate);
                    if (hex != null)
                    {
                        var emblemItem = _context.Items.FirstOrDefault(x => x.InGameKey == mostUsedEmblem);
                        if (emblemItem != null)
                        {
                            hex.CurrentItems.Add(new HexItem { Item = emblemItem });
                            itemSlots--;
                        }
                    }
                }
            }

            foreach (var unit in sortedUnits)
            {
                var hex = guide.Hexes.FirstOrDefault(h => h.Unit.InGameKey == unit);
                if (hex == null) continue;

                var unitItems = _unitItemRates[unit]
                    .OrderByDescending(kv => kv.Value)
                    .Select(kv => kv.Key)
                    .ToList();

                var itemsToAdd = Math.Min(itemSlots, 3 - hex.CurrentItems.Count);
                foreach (var itemKey in unitItems)
                {
                    if (itemKey.Contains("Emblem") && !CanAddEmblem(itemKey)) continue;

                    if (itemsToAdd <= 0) break;

                    var item = _context.Items.FirstOrDefault(x => x.InGameKey == itemKey);
                    if (item == null) continue;
                    if (item.Name.Contains("Gloves") && (hex.CurrentItems.Any() || unit == team[0]) ||
                        hex.CurrentItems.Any(item => item.Item.InGameKey.Contains("Gloves")) ||
                        hex.CurrentItems.Any(item => item.Item.InGameKey == itemKey))
                    {
                        continue;
                    }

                    hex.CurrentItems.Add(new HexItem { Item = item });
                    itemSlots--;
                    itemsToAdd--;
                }
            }
            var (playStyle, difficulty) = CalculatePlayStyleAndDifficulty(team, guide);
            guide.PlayStyle = playStyle;
            guide.DifficultyLevel = difficulty;

            PositionSelector positionSelector = new PositionSelector();
            guide.Hexes = positionSelector.CalculateUnitPositions(guide.Hexes);

            return guide;
        }

        private (string PlayStyle, string Difficulty) CalculatePlayStyleAndDifficulty(List<string> team, UserGuide guide)
        {
            int tier1WithThreeItems = 0;
            int tier2WithThreeItems = 0;
            int tier3WithThreeItems = 0;
            int tier4WithThreeItems = 0;
            int tier5WithThreeItems = 0;
            int totalTier4Units = 0;
            int totalTier5Units = 0;

            foreach (var unit in team)
            {
                var existingUnit = _context.Units.FirstOrDefault(u => u.InGameKey == unit);
                if (existingUnit == null) continue;

                var unitTier = existingUnit.Tier;
                var itemCount = guide.Hexes.FirstOrDefault(h => h.Unit.InGameKey == unit)?.CurrentItems.Count ?? 0;

                if (itemCount == 3)
                {
                    switch (unitTier)
                    {
                        case 1:
                            tier1WithThreeItems++;
                            break;
                        case 2:
                            tier2WithThreeItems++;
                            break;
                        case 3:
                            tier3WithThreeItems++;
                            break;
                        case 4:
                            tier4WithThreeItems++;
                            break;
                        case 5:
                            tier5WithThreeItems++;
                            break;
                    }
                }

                if (unitTier == 4)
                {
                    totalTier4Units++;
                }
                else if (unitTier == 5)
                {
                    totalTier5Units++;
                }
            }

            string playStyle;
            string difficulty;

            if ((tier5WithThreeItems >= 1) || (totalTier5Units > 2))
            {
                playStyle = "Fast 9";
                difficulty = "Hard";
            }
            else if ((tier4WithThreeItems >= 2) || (tier4WithThreeItems >= 1 && totalTier4Units >= 3))
            {
                playStyle = "Fast 8";
                difficulty = "Hard";
            }
            else if ((tier3WithThreeItems >= 2))
            {
                playStyle = "Level 7 Slow Roll";
                difficulty = "Medium";
            }
            else if (tier2WithThreeItems >= 2)
            {
                playStyle = "Level 6 Slow Roll";
                difficulty = "Easy";
            }
            else if (tier1WithThreeItems >= 2)
            {
                playStyle = "Level 5 Slow Roll";
                difficulty = "Easy";
            }
            else
            {
                playStyle = "Default";
                difficulty = "Default";
            }

            return (playStyle, difficulty);
        }

        private void UpdateTraitsInGuide(UserGuide guide)
        {
            guide.Traits = _currentTraits.Select(ct => new GuideTrait
            {
                Trait = _traits.First(t => t.Name == ct.Key),
                Value = ct.Value,
                Tier = _traitStats
                    .Where(ts => ts.Name == ct.Key && ts.NumUnits <= ct.Value)
                    .OrderByDescending(ts => ts.NumUnits)
                    .FirstOrDefault()?.NumUnits ?? 0
            }).ToList();
        }

        private void UpdateAugmentsInGuide(UserGuide guide, List<string> team)
        {
            var topAugments = new Dictionary<string, int>();
            var itemKeys = guide.Hexes
                                 .SelectMany(h => h.CurrentItems)
                                 .Select(ci => ci.Item.InGameKey)
                                 .ToList();

            foreach (var unit in team)
            {
                foreach (var augment in _augmentStats[unit])
                {
                    if (augment.Key.Contains("Carry"))
                    {
                        var remainingString = augment.Key.Replace("TFT11_Augment_", "").Replace("Carry", "");
                        var matchingUnit = team.FirstOrDefault(t => t.Contains(remainingString));
                        if (matchingUnit == null) continue;
                        var hex = guide.Hexes.FirstOrDefault(h => h.Unit.InGameKey == matchingUnit);
                        if (hex == null || hex.CurrentItems.Count != 3) continue;

                    }
                    if (augment.Key.Contains("Crest") || augment.Key.Contains("Crown"))
                    {
                        var remainingString = augment.Key.Replace("TFT11_Augment_", "").Replace("Crest", "").Replace("Crown", "");
                        if (!itemKeys.Any(e => e.Contains(remainingString))) continue;
                    }

                    if (!topAugments.ContainsKey(augment.Key))
                    {
                        topAugments[augment.Key] = 0;
                    }
                    topAugments[augment.Key] += augment.Value;
                }
            }
            var top3Augments = topAugments.OrderByDescending(a => a.Value).Take(3).Select(a => a.Key).ToList();
            var augmentEntities = _context.Augments.Where(a => top3Augments.Contains(a.InGameKey)).ToList();

            guide.Augments = augmentEntities.Select(a => new GuideAugment
            {
                Augment = a
            }).ToList();
        }

        private double CalculateEmblemUsagePercentage()
        {
            var totalEmblemCount = _emblems.Values.Sum(dic => dic.Values.Sum());
            return (double)totalEmblemCount / _matchCount * 100;
        }

        private string? GetMostUsedEmblem()
        {
            var mostUsedEmblems = _emblems.Values.SelectMany(dic => dic)
                                                .OrderByDescending(kv => kv.Value)
                                                .ToList();

            foreach (var emblem in mostUsedEmblems)
            {
                if (!CanAddEmblem(emblem.Key)) continue;
                var currentTrait = emblem.Key.Replace("TFT11_Item_", "").Replace("Emblem", "").Replace("Item", "");
                _currentTraits[currentTrait]++;
                return emblem.Key;
            }
            return null;
        }

        private bool CanAddEmblem(string itemKey)
        {
            if (!itemKey.Contains("Emblem"))
                return false;

            var nameToKeep = itemKey.Replace("TFT11_Item_", "").Replace("Emblem", "").Replace("Item", "");

            var matchingTraitStat = _traitStats.FirstOrDefault(ts =>
                ts.Name == $"TFT11_{nameToKeep}" &&
                _currentTraits.ContainsKey(nameToKeep) &&
                _currentTraits[nameToKeep] + 1 > 2 &&
                _currentTraits[nameToKeep] + 1 == ts.NumUnits);

            return matchingTraitStat != null;
        }

        private string? GetUnitWithHighestEmblemRate(string emblem)
        {
            var unitWithHighestEmblemRate = _units
                .OrderByDescending(unit => _unitItemRates.ContainsKey(unit.InGameKey) && _unitItemRates[unit.InGameKey].ContainsKey(emblem) ? _unitItemRates[unit.InGameKey][emblem] : 0)
                .FirstOrDefault()?.InGameKey;
            return unitWithHighestEmblemRate;
        }
    }
}