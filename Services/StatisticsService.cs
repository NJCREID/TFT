using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;
using TFT_API.Data;
using TFT_API.Models.Match;
using TFT_API.Models.Stats;
using TFT_API.Models.Stats.AugmentStats;
using TFT_API.Models.Stats.CompStats;
using TFT_API.Models.Stats.ItemStats;
using TFT_API.Models.Stats.TraitStats;
using TFT_API.Models.Stats.UnitStats;
using TFT_API.Models.UserGuides;

namespace TFT_API.Services
{
    /// <summary>
    /// Provides statistical calculations and storage for TFT matches.
    /// </summary>
    public class StatisticsService(TFTContext context, IMemoryCache memoryCache)
    {
        private readonly TFTContext _context = context;
        private readonly IMemoryCache _memoryCache = memoryCache;
        private Dictionary<string, UnitStat> _unitStats = [];
        private Dictionary<string, StarredUnitStat> _starUnitStats = [];
        private Dictionary<string, Dictionary<int, TraitStat>> _traitStats = [];
        private Dictionary<string, AugmentStat> _augmentStats = [];
        private Dictionary<string, ItemStat> _itemStats = [];
        private Dictionary<string, CompStat> _compStats = [];
        private Dictionary<string, int[]> _tiersData = [];
        private List<UserGuide> _comps = [];


        /// <summary>
        /// Calculates and stores statistics for TFT matches asynchronously.
        /// </summary>
        public async Task CalculateAndStoreStatisticsAsync()
        {
            var leagues = new[] { "Challenger", "GrandMaster", "Master", "" };

            using var transaction = await _context.Database.BeginTransactionAsync();
            try
            {
                var statsToRemove = await _context.AugmentStats.SelectMany(a => a.Stats)
                    .Concat(_context.UnitStats.Select(a => a.Stat))
                    .Concat(_context.ItemStats.Select(a => a.Stat))
                    .Concat(_context.TraitStats.Select(a => a.Stat))
                    .Concat(_context.StarredUnitStats.Select(a => a.Stat))
                    .Concat(_context.CompStats.Select(a => a.Stat))
                    .Distinct()
                    .ToListAsync();

                _context.Stats.RemoveRange(statsToRemove);
                await _context.SaveChangesAsync();
                //auto generated guides
                _comps = await _context.UserGuides.AsSplitQuery().Where(ug => ug.IsAutoGenerated == true)
                    .Include(u => u.InitialUnit)
                    .Include(u => u.Hexes)
                        .ThenInclude(uh => uh.Unit).ToListAsync();
                //Trait tiers
                _tiersData = await _context.Traits
                    .Select(t => new
                    {
                        t.InGameKey,
                        Levels = t.Tiers.Select(tier => tier.Level).ToArray()
                    })
                    .ToDictionaryAsync(
                        t => t.InGameKey,
                        t => t.Levels
                    );

                foreach (var league in leagues)
                {
                    await ProcessLeagueMatchesAsync(league);
                    ClearLeagueCacheEntries(league);
                }
                await transaction.CommitAsync();
            }
            catch
            {
                await transaction.RollbackAsync();
                throw;
            }
        }

        /// <summary>
        /// Clears cached entries for the specified league.
        /// </summary>
        /// <param name="league">The league for which cache entries are to be cleared.</param>
        private void ClearLeagueCacheEntries(string league)
        {
            _memoryCache.Remove($"augmentStat_{league}");
            _memoryCache.Remove($"traitStat_{league}");
            _memoryCache.Remove($"unitStat_{league}");
            _memoryCache.Remove($"itemStat_{league}");
            _memoryCache.Remove($"compStat_{league}");
        }

        /// <summary>
        /// Processes matches for a specified league and updates statistics.
        /// </summary>
        /// <param name="league">The league to process matches for.</param>
        private async Task ProcessLeagueMatchesAsync(string league)
        {
            var matches = await GetMatchesAsync(league);
            
            //Reset dictionaries from previous league
            InitializeDictionaries();
            var (TotalMatches, Top4, Win, Place) = CalculateMatchResults(matches);

            await CheckVisibilityAsync(_unitStats);
            await CheckVisibilityAsync(_itemStats);
            await CheckVisibilityAsync(_augmentStats);
            await CheckVisibilityAsync(_traitStats);

            double averagePlace = TotalMatches != 0 ? Place / (double)TotalMatches : 0;

            UpdateDeltas(averagePlace);

            await SaveStatisticsAsync(league, TotalMatches);
        }

        /// <summary>
        /// Retrieves matches for the specified league.
        /// </summary>
        /// <param name="league">The league to retrieve matches for.</param>
        /// <returns>A list of match data transfer objects.</returns>
        private async Task<List<MatchDto>> GetMatchesAsync(string league)
        {
            var matchesQuery = _context.Matches
                .AsSplitQuery()
                .Select(m => new MatchDto
                {
                    Placement = m.Placement,
                    Augments = m.Augments,
                    League = m.League,
                    Units = m.Units.Select(u => new MatchUnitDto { CharacterId = u.CharacterId, ItemNames = u.ItemNames, Tier = u.Tier }).ToList(),
                    Traits = m.Traits.Select(t => new MatchTraitDto { Name = t.Name, NumUnits = t.NumUnits }).ToList()
                });

            if (!string.IsNullOrEmpty(league))
            {
                matchesQuery = matchesQuery.Where(m => m.League == league);
            }

            return await matchesQuery.ToListAsync();
        }


        /// <summary>
        /// Initializes dictionaries to store statistics for units, traits, augments, items, and comps.
        /// </summary>
        private void InitializeDictionaries()
        {
            _unitStats = [];
            _starUnitStats = [];
            _traitStats = [];
            _augmentStats = [];
            _itemStats = [];
            _compStats = [];
        }

        /// <summary>
        /// Calculates the results of matches and returns summary statistics.
        /// </summary>
        /// <param name="matches">A list of match data transfer objects.</param>
        /// <returns>A tuple containing total matches, top 4 placements, wins, and total placement.</returns>
        private (int TotalMatches, int Top4, int Win, int Place) CalculateMatchResults(List<MatchDto> matches)
        {
            int totalMatches = matches.Count;
            int top4 = 0, win = 0, place = 0;

            foreach (var match in matches)
            {
                var placement = match.Placement;
                if (placement <= 4) top4++;
                if (placement == 1) win++;
                place += placement;

                ProcessComps(match, placement);
                ProcessUnits( match, placement);
                ProcessTraits( match, placement);
                ProcessAugments(match, placement);
            }

            return (totalMatches, top4, win, place);
        }

        /// <summary>
        /// Updates the delta values for various statistics based on the average placement.
        /// </summary>
        /// <param name="averagePlace">The average placement to use for delta calculations.</param>
        private void UpdateDeltas(double averagePlace)
        {
            void UpdateDelta(Stat stat)
            {
                stat.Delta = stat.Games != 0 ?  (stat.Place / (double)stat.Games) - averagePlace : averagePlace;
            }

            foreach (var comp in _compStats.Values) UpdateDelta(comp.Stat);
            foreach (var unit in _unitStats.Values) UpdateDelta(unit.Stat);
            foreach (var unit in _starUnitStats.Values) UpdateDelta(unit.Stat);
            foreach (var item in _itemStats.Values) UpdateDelta(item.Stat);
            foreach (var traitsList in _traitStats.Values) foreach (var trait in traitsList.Values) UpdateDelta(trait.Stat);
            foreach (var augment in _augmentStats.Values) foreach (var stat in augment.Stats) UpdateDelta(stat);
        }


        /// <summary>
        /// Saves the calculated statistics for the specified league to the database.
        /// </summary>
        /// <param name="league">The league for which statistics are to be saved.</param>
        /// <param name="totalMatches">The total number of matches played.</param>
        private async Task SaveStatisticsAsync(
            string league, 
            int totalMatches)
        {
            _context.BaseCompStat.RemoveRange(_context.BaseCompStat.Where(s => s.League == league));
            _context.BaseUnitStat.RemoveRange(_context.BaseUnitStat.Where(s => s.League == league));
            _context.BaseTraitStat.RemoveRange(_context.BaseTraitStat.Where(s => s.League == league));
            _context.BaseAugmentStat.RemoveRange(_context.BaseAugmentStat.Where(s => s.League == league));
            _context.BaseItemStat.RemoveRange(_context.BaseItemStat.Where(s => s.League == league));
            await _context.SaveChangesAsync();

            await CreateBaseStatsAsync(totalMatches, league);
        }

        /// <summary>
        /// Creates base statistics for various entities and saves them to the database asynchronously.
        /// </summary>
        /// <param name="totalMatches">The total number of matches played.</param>
        /// <param name="league">The league for which base statistics are to be created.</param>
        private async Task CreateBaseStatsAsync(
            int totalMatches,
            string league)
        {
            foreach (var unitStat in _unitStats.Values)
            {
                var matchingUnit = await _context.Units.FirstOrDefaultAsync(u => u.InGameKey == unitStat.InGameKey);
                if (matchingUnit != null)
                {
                    unitStat.Name = matchingUnit.Name;
                    if (_starUnitStats.TryGetValue(unitStat.InGameKey, out var starredUnitStat))
                    {
                        starredUnitStat.Name = matchingUnit.Name;
                    }
                }
            }

            foreach (var traitStatList in _traitStats.Values)
            {
                foreach (var traitStat in traitStatList.Values)
                {
                    var matchingTrait = await _context.Traits.FirstOrDefaultAsync(t => t.InGameKey == traitStat.InGameKey);
                    if (matchingTrait != null)
                    {
                        traitStat.Name = matchingTrait.Name;
                    }
                }
            }

            foreach (var augmentStat in _augmentStats.Values)
            {
                var matchingAugment = await _context.Augments.FirstOrDefaultAsync(a => a.InGameKey == augmentStat.InGameKey);
                if (matchingAugment != null)
                {
                    augmentStat.Name = matchingAugment.Name;
                }
            }

            foreach (var itemStat in _itemStats.Values)
            {
                var matchingItem = await _context.Items.FirstOrDefaultAsync(i => i.InGameKey == itemStat.InGameKey);
                if (matchingItem != null)
                {
                    itemStat.Name = matchingItem.Name;
                }
            }

            await _context.BaseCompStat.AddAsync(new BaseCompStat
            {
                Games = totalMatches,
                CompStats = [.. _compStats.Values],
                League = league
            });
            await _context.BaseUnitStat.AddAsync(new BaseUnitStat
            {
                Games = totalMatches,
                UnitStats = [.. _unitStats.Values],
                StarredUnitStats = [.. _starUnitStats.Values],
                League = league
            });
            await _context.BaseTraitStat.AddAsync(new BaseTraitStat
            {
                Games = totalMatches,
                TraitStats = _traitStats.Values.SelectMany(dict => dict.Values).ToList(),
                League = league
            });
            await _context.BaseAugmentStat.AddAsync(new BaseAugmentStat
            {
                Games = totalMatches,
                AugmentStats = [.. _augmentStats.Values],
                League = league
            });
            await _context.BaseItemStat.AddAsync(new BaseItemStat
            {
                Games = totalMatches,
                ItemStats = [.. _itemStats.Values],
                League = league
            });
            await _context.SaveChangesAsync();
        }

        /// <summary>
        /// Processes and updates statistics for comps based on match results.
        /// </summary>
        /// <param name="match">The match data transfer object containing match details.</param>
        /// <param name="placement">The placement of the match.</param>
        private void ProcessComps(
            MatchDto match,
            int placement)
        {
            foreach (var team in _comps)
            {
                if (team.InitialUnit == null) continue;
                int unitCount = match.Units.Count(champion => team.Hexes.Any(hex => hex.Unit.InGameKey == champion.CharacterId));
                if (unitCount >= 6)
                {
                    if (!_compStats.TryGetValue(team.InitialUnit.InGameKey, out var compStat))
                    {
                        compStat = new CompStat { Name = team.InitialUnit.Name, InGameKey = team.InitialUnit.InGameKey, Units = [], Stat = new Stat() };
                        List<CompStatUnit> compStatUnits = team.Hexes
                            .Select(hex => new CompStatUnit { Unit = hex.Unit })
                            .ToList();
                        compStat.Units.AddRange(compStatUnits);
                        _compStats[team.InitialUnit.InGameKey] = compStat;
                    }
                    var stat = compStat.Stat;
                    stat.Games++;
                    stat.Place += placement;
                    stat.Top4 += placement <= 4 ? 1 : 0;
                    stat.Win += placement == 1 ? 1 : 0;
                }
            }
        }

        /// <summary>
        /// Processes and updates statistics for units based on match results.
        /// </summary>
        /// <param name="match">The match data transfer object containing match details.</param>
        /// <param name="placement">The placement of the match.</param>
        private void ProcessUnits(
            MatchDto match,
            int placement)
        {
            foreach (var unit in match.Units)
            {
                if (!_unitStats.TryGetValue(unit.CharacterId, out var unitStat))
                {
                    unitStat = new UnitStat { InGameKey = unit.CharacterId, Stat = new Stat() };
                    _unitStats[unit.CharacterId] = unitStat;
                }

                var stat = unitStat.Stat;
                stat.Games++;
                stat.Place += placement;
                stat.Top4 += placement <= 4 ? 1 : 0;
                stat.Win += placement == 1 ? 1 : 0;

                if (unit.Tier == 3)
                {
                    if (!_starUnitStats.TryGetValue(unit.CharacterId, out var starUnitStat))
                    {
                        starUnitStat = new StarredUnitStat { InGameKey = unit.CharacterId, Stat = new Stat() };
                        _starUnitStats[unit.CharacterId] = starUnitStat;
                    }

                    var starStat = starUnitStat.Stat;
                    starStat.Games++;
                    starStat.Place += placement;
                    starStat.Top4 += placement <= 4 ? 1 : 0;
                    starStat.Win += placement == 1 ? 1 : 0;
                }

                ProcessItems(unit, placement);
            }
        }

        /// <summary>
        /// Processes and updates statistics for items based on match results.
        /// </summary>
        /// <param name="unit">The match unit data transfer object containing item details.</param>
        /// <param name="placement">The placement of the match.</param>
        private void ProcessItems(
            MatchUnitDto unit, 
            int placement)
        {
            foreach (var item in unit.ItemNames)
            {
                if (!_itemStats.TryGetValue(item, out var itemStat))
                {
                    itemStat = new ItemStat { InGameKey = item, Stat = new Stat() };
                    _itemStats[item] = itemStat;
                }

                var itemStatInstance = itemStat.Stat;
                itemStatInstance.Games++;
                itemStatInstance.Place += placement;
                itemStatInstance.Top4 += placement <= 4 ? 1 : 0;
                itemStatInstance.Win += placement == 1 ? 1 : 0;
            }
        }

        /// <summary>
        /// Processes and updates statistics for traits based on match results.
        /// </summary>
        /// <param name="match">The match data transfer object containing match details.</param>
        /// <param name="placement">The placement of the match.</param>
        private void ProcessTraits(
            MatchDto match,
            int placement)
        {
            foreach (var trait in match.Traits)
            {
                if (_tiersData.TryGetValue(trait.Name, out var tiers))
                {
                    // Floor the traits tier as to not gain statistics on non contributing trait tiers.
                    var flooredNumUnits = tiers.OrderBy(t => t).LastOrDefault(t => t <= trait.NumUnits);
                    if (flooredNumUnits == 0) continue;
                    trait.NumUnits = flooredNumUnits;
                }

                if (!_traitStats.TryGetValue(trait.Name, out var traitDict))
                {
                    traitDict = [];
                    _traitStats[trait.Name] = traitDict;
                }

                if (!traitDict.TryGetValue(trait.NumUnits, out var traitStat))
                {
                    traitStat = new TraitStat { InGameKey = trait.Name, NumUnits = trait.NumUnits, Stat = new Stat() };
                    traitDict[trait.NumUnits] = traitStat;
                }

                var traitStatInstance = traitDict[trait.NumUnits].Stat;
                traitStatInstance.Games++;
                traitStatInstance.Place += placement;
                traitStatInstance.Top4 += placement <= 4 ? 1 : 0;
                traitStatInstance.Win += placement == 1 ? 1 : 0;
            }
        }

        /// <summary>
        /// Processes and updates statistics for augments based on match results.
        /// </summary>
        /// <param name="match">The match data transfer object containing match details.</param>
        /// <param name="placement">The placement of the match.</param>
        private void ProcessAugments( 
            MatchDto match,
            int placement)
        {
            for (int i = 0; i < match.Augments.Count; i++)
            {
                var augment = match.Augments[i];
                if (!_augmentStats.TryGetValue(augment, out var augmentStat))
                {
                    augmentStat = new AugmentStat { InGameKey = augment, Stats = [] };
                    _augmentStats[augment] = augmentStat;
                }

                while (augmentStat.Stats.Count <= i)
                {
                    augmentStat.Stats.Add(new Stat());
                }

                var stat = augmentStat.Stats[i];
                stat.Games++;
                stat.Place += placement;
                stat.Top4 += placement <= 4 ? 1 : 0;
                stat.Win += placement == 1 ? 1 : 0;
            }
        }

        /// <summary>
        /// Checks the visibility of units, items, augments, and traits for the current set.
        /// Removes all non visible objects.
        /// </summary>
        /// <typeparam name="T">The type of the statistics to check visibility for.</typeparam>
        /// <param name="dict">The dictionary of statistics to filter based on visibility.</param>
        private async Task CheckVisibilityAsync<T>(Dictionary<string, T> dict)
        {
            var units = await _context.Units.AsNoTracking().ToListAsync();
            var items = await _context.Items.AsNoTracking().ToListAsync();
            var augments = await _context.Augments.AsNoTracking().ToListAsync();
            var traits = await _context.Traits.AsNoTracking().ToListAsync();

            var unitDict = units.ToDictionary(u => u.InGameKey, u => u.IsHidden != true);
            var itemDict = items.ToDictionary(i => i.InGameKey, i => i.IsHidden != true);
            var augmentDict = augments.ToDictionary(a => a.InGameKey, a => a.IsHidden != true);
            var traitDict = traits.ToDictionary(t => t.InGameKey, t => t.IsHidden != true);

            var filteredDict = new Dictionary<string, T>();

            bool IsVisible(string key)
            {
                if (unitDict.TryGetValue(key, out var unitVisible)) return unitVisible;
                if (itemDict.TryGetValue(key, out var itemVisible)) return itemVisible;
                if (augmentDict.TryGetValue(key, out var augmentVisible)) return augmentVisible;
                if (traitDict.TryGetValue(key, out var traitVisible)) return traitVisible;
                return false;
            }

            // Add only visible objects to the filteredDict
            foreach (var kvp in dict)
            {
                var key = kvp.Key;
                var stat = kvp.Value;

                if (IsVisible(key))
                {
                    filteredDict[key] = stat;
                }
            }

            dict.Clear();
            foreach (var kvp in filteredDict)
            {
                dict[kvp.Key] = kvp.Value;
            }
        }
    }
}
